import { app, BrowserWindow, ipcMain, shell } from 'electron';
import path from 'path';
import { spawn, ChildProcess } from 'child_process';
import fs from 'fs/promises';
import { findKuuzukiServer } from './server-detector';
import { terminalManager, TerminalMode } from './terminal-manager';
// Conditionally import node-pty with error handling
let pty: typeof import('node-pty') | null = null;
try {
  pty = require('node-pty');
} catch (error) {
  console.warn('node-pty not available, PTY features will be disabled:', error);
}

let mainWindow: BrowserWindow | null = null;
let kuuzukiProcess: ChildProcess | null = null;
let ptyProcess: any | null = null; // Type will be IPty when available

const isDevelopment = process.env.NODE_ENV !== 'production';

async function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, '../preload/index.js')
    },
    icon: path.join(__dirname, '../../assets/icon.png'),
    titleBarStyle: 'hiddenInset',
    backgroundColor: '#1e1e1e'
  });

  if (isDevelopment) {
    mainWindow.loadURL('http://localhost:5174');
    // mainWindow.webContents.openDevTools(); // Uncomment to show dev tools
  } else {
    mainWindow.loadFile(path.join(__dirname, '../../dist/index.html'));
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
  });

  // Handle external links
  mainWindow.webContents.setWindowOpenHandler(({ url }: { url: string }) => {
    shell.openExternal(url);
    return { action: 'deny' };
  });
}

async function startKuuzukiServer(): Promise<string> {
  // Check if server is already running
  const existingServer = await findKuuzukiServer();
  if (existingServer) {
    return existingServer.url;
  }

  // Find kuuzuki binary
  const possiblePaths = [
    path.join(__dirname, '../../assets/bin/kuuzuki'),
    path.join(__dirname, '../../../opencode/kuuzuki-cli'),
    path.join((process as any).resourcesPath, 'bin/kuuzuki'),
    '/usr/local/bin/kuuzuki',
    '/usr/bin/kuuzuki'
  ];

  let kuuzukiBinary = '';
  for (const binPath of possiblePaths) {
      console.log("Checking binary:", binPath);
    try {
      await fs.access(binPath, fs.constants.X_OK);
      kuuzukiBinary = binPath;
      break;
    } catch {
      // Continue searching
    }
  }

    console.log("Found kuuzuki binary:", kuuzukiBinary);
  if (!kuuzukiBinary) {
    throw new Error('Kuuzuki binary not found');
  }

  // Start kuuzuki in headless mode with dynamic port
  return new Promise((resolve, reject) => {
    kuuzukiProcess = spawn(kuuzukiBinary, ['serve', '--port', '0'], {
      env: {
        ...process.env,
        KUUZUKI_HEADLESS: '1'
      }
    });

    let serverUrl = '';
    const timeout = setTimeout(() => {
      if (kuuzukiProcess) {
        kuuzukiProcess.kill();
      }
      reject(new Error('Server startup timeout'));
    }, 30000);

    kuuzukiProcess.stdout?.on('data', (data) => {
      const output = data.toString();
      console.log('Kuuzuki:', output);
      
      // Look for server URL in output
      const urlMatch = output.match(/Server running at (http:\/\/\S+)/);
      if (urlMatch) {
        serverUrl = urlMatch[1];
        clearTimeout(timeout);
        resolve(serverUrl);
      }
    });

    kuuzukiProcess.stderr?.on('data', (data) => {
      console.error('Kuuzuki error:', data.toString());
    });

    kuuzukiProcess.on('error', (error) => {
      clearTimeout(timeout);
      reject(error);
    });

    kuuzukiProcess.on('exit', (code) => {
      clearTimeout(timeout);
      if (!serverUrl) {
        reject(new Error(`Kuuzuki exited with code ${code}`));
      }
    });
  });
}

// IPC Handlers
ipcMain.handle('start-server', async () => {
  try {
    const url = await startKuuzukiServer();
    return { success: true, url };
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : String(error) };
  }
});

ipcMain.handle('find-server', async () => {
  const server = await findKuuzukiServer();
  return server;
});

ipcMain.handle('check-server-health', async (_event, url: string) => {
  try {
    const response = await fetch(`${url}/health`);
    return response.ok;
  } catch {
    return false;
  }
});

// Terminal PTY handlers
ipcMain.handle('terminal-spawn', async () => {
  console.log("Terminal spawn requested");
  if (ptyProcess || kuuzukiProcess) {
    return { success: false, error: 'Terminal already running' };
  }

  try {
    // Find kuuzuki binary
    const possiblePaths = [
      path.join(__dirname, '../../assets/bin/kuuzuki'),
      path.join(__dirname, '../../../opencode/kuuzuki-cli'),
      path.join((process as any).resourcesPath, 'bin/kuuzuki'),
      '/usr/local/bin/kuuzuki',
      '/usr/bin/kuuzuki'
    ];

    let kuuzukiBinary = '';
    for (const binPath of possiblePaths) {
      console.log("Checking binary:", binPath);
      try {
        await fs.access(binPath, fs.constants.X_OK);
        kuuzukiBinary = binPath;
        break;
      } catch {
        // Continue searching
      }
    }

    console.log("Found kuuzuki binary:", kuuzukiBinary);
    if (!kuuzukiBinary) {
      throw new Error('Kuuzuki binary not found');
    }

    // Get current working directory
    // const cwd = process.cwd();

    // Check if PTY is available
    if (!pty) {
      console.warn('PTY not available, using fallback terminal');
      // Fallback: spawn regular process
      kuuzukiProcess = spawn(kuuzukiBinary, ['tui'], {
        cwd: process.cwd(),
        env: process.env,
        stdio: 'pipe'
      });
      
      kuuzukiProcess.stdout?.on('data', (data) => {
        mainWindow?.webContents.send('terminal-data', data.toString());
      });
      
      kuuzukiProcess.stderr?.on('data', (data) => {
        mainWindow?.webContents.send('terminal-data', data.toString());
      });
      
      kuuzukiProcess.on('exit', () => {
        kuuzukiProcess = null;
        mainWindow?.webContents.send('terminal-exit');
      });
      
      return { success: true };
    }
    
    // Spawn PTY with kuuzuki TUI
    const cwd = process.cwd();
    
    ptyProcess = pty.spawn(kuuzukiBinary, ["tui"], {
      name: "xterm-256color",
      cols: 80,
      rows: 30,
      cwd,
      env: process.env
    });
    
    ptyProcess.onData((data: string) => {
      mainWindow?.webContents.send("terminal-data", data);
    });
    
    ptyProcess.onExit(() => {
      ptyProcess = null;
      mainWindow?.webContents.send("terminal-exit");
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : String(error) };
  }
});

ipcMain.on('terminal-write', (_event, data: string) => {
  if (ptyProcess && pty) {
    ptyProcess.write(data);
  } else if (kuuzukiProcess && kuuzukiProcess.stdin) {
    kuuzukiProcess.stdin.write(data);
  }
});

ipcMain.handle('terminal-resize', async (_event, cols: number, rows: number) => {
  if (ptyProcess && pty) {
    ptyProcess.resize(cols, rows);
  }
  // Regular process doesn't support resize
  return { success: true };
});

ipcMain.handle('terminal-kill', async () => {
  if (ptyProcess) {
    ptyProcess.kill();
    ptyProcess = null;
  }
  if (kuuzukiProcess) {
    kuuzukiProcess.kill();
    kuuzukiProcess = null;
  }
  return { success: true };
});

// App event handlers
app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', () => {
  if (kuuzukiProcess) {
    kuuzukiProcess.kill();
  }
  if (ptyProcess) {
    ptyProcess.kill();
  }
});

process.on('SIGINT', () => {
  if (kuuzukiProcess) {
    kuuzukiProcess.kill();
  }
  if (ptyProcess) {
    ptyProcess.kill();
  }
  app.quit();
});